<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sbblog | sharedInstance]]></title>
  <link href="http://sharedinstance.net/categories/sbblog/atom.xml" rel="self"/>
  <link href="http://sharedinstance.net/"/>
  <updated>2015-02-15T18:53:31+10:30</updated>
  <id>http://sharedinstance.net/</id>
  <author>
    <name><![CDATA[sharedInstance]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Doing tweak settings the right-er way]]></title>
    <link href="http://sharedinstance.net/2015/02/settings-the-right-way-redux/"/>
    <updated>2015-02-15T18:50:56+10:30</updated>
    <id>http://sharedinstance.net/2015/02/settings-the-right-way-redux</id>
    <content type="html"><![CDATA[<p>As it turned out, retrieving tweak settings from <code>NSUserDefaults</code> as outlined in <a href="/2014/11/settings-the-right-way/">the post I wrote</a> a few months ago proved to not be very robust and still had problems within a sandboxed process.</p>

<p>At one point several months prior to the <a href="https://hbang.github.io/libcephei/">libcephei</a> update a few weeks ago, I thought about how preferences loading could be improved, and started working on a class called <code>HBPreferences</code>. The idea is that either you keep an instance of this class as a global variable in your tweak, and use it basically as you would with <code>NSUserDefaults</code>. Or, you can take it one step further than what <code>NSUserDefaults</code> is capable of and &ldquo;register&rdquo; a variable&rsquo;s pointer so it&rsquo;ll always be up to date with no preference reloading code required in your tweak.</p>

<p>If you don&rsquo;t already understand the changes made in iOS 8, refer to the first few paragraphs of <a href="/2014/11/settings-the-right-way/">the original post</a>.</p>

<!--more-->


<h2>Setting up libcephei with Theos</h2>

<p>You will need to copy libcephei&rsquo;s headers and libraries to your development machine so the compiler and linker respectively are aware of it.</p>

<p>You won&rsquo;t find libcephei in Cydia by searching for &ldquo;Cephei&rdquo; because it&rsquo;s been set as hidden. However, you can install a package that depends on it like TypeStatus, or install &ldquo;APT 0.7 Strict&rdquo; (<code>apt7</code>) if you don&rsquo;t already have it and run:</p>

<pre><code class="bash">apt-get install ws.hbang.common
</code></pre>

<p>On your development machine, copy the required files like so:</p>

<pre><code class="bash">THEOS=/opt/theos  # if you don't already have $THEOS set, set it to the location of theos
THEOS_DEVICE_IP=iphone  # and set these two if you haven't already
THEOS_DEVICE_PORT=22

scp -P $THEOS_DEVICE_PORT root@$THEOS_DEVICE_IP:/usr/lib/libcephei\* $THEOS/lib
scp -r -P $THEOS_DEVICE_PORT root@$THEOS_DEVICE_IP:/usr/include/\{Cephei,CepheiPrefs\} $THEOS/include
</code></pre>

<p>Now, open your project&rsquo;s makefile and add:</p>

<pre><code class="make">TargetName_LIBRARIES += cephei
</code></pre>

<p>In your <code>control</code> file, add <code>ws.hbang.common</code> to your dependencies, and set it to require the latest version or newer. At the time of writing, that&rsquo;s version 1.2, so for example:</p>

<pre><code>Depends: mobilesubstrate, ws.hbang.common (&gt;= 1.2)
</code></pre>

<h2><code>NSUserDefaults</code> compatible method</h2>

<p>This method has almost no changes from the example on the original post - just replace <code>NSUserDefaults</code> with <code>HBPreferences</code> and initialise with the <code>initWithIdentifier:</code> method like so:</p>

<pre><code class="objc">static NSString *const kHBCBPreferencesDomain = @"ws.hbang.cobalia";
static NSString *const kHBCBPreferencesEnabledKey = @"Enabled";
static NSString *const kHBCBPreferencesSwitchesKey = @"Switches";
static NSString *const kHBCBPreferencesSectionLabelKey = @"SectionLabel";
static NSString *const kHBCBPreferencesSwitchLabelsKey = @"SwitchLabels";

HBPreferences *preferences;

%init {
    preferences = [[HBPreferences alloc] initWithIdentifier:kHBCBPreferencesDomain];

    [preferences registerDefaults:@{
        kHBCBPreferencesEnabledKey: @YES,
        kHBCBPreferencesSwitchesKey: @[ /* ... */ ],
        kHBCBPreferencesSectionLabelKey: @YES,
        kHBCBPreferencesSwitchLabelsKey: @YES
    }];
}
</code></pre>

<p>I use constants for strings that shouldn&rsquo;t ever change - you don&rsquo;t need to but I&rsquo;d recommend it. If you prefer, you can also set keys on <code>preferences.defaults</code> directly, as it&rsquo;s an <code>NSMutableDictionary</code>.</p>

<p>Once again, it&rsquo;s as simple as <code>[preferences objectForKey:kHBCBPreferencesEnabledKey]</code> to get an Objective-C object (or nil if there&rsquo;s no value and no default registered), or get a primitive directly using any of <code>bool</code>, <code>double</code>, <code>integer</code>, or <code>floatForKey:</code>.</p>

<h2>Legacy library support</h2>

<p>As mentioned in the previous post, at the time that <a href="https://www.hbang.ws/tweaks/cobalia">Cobalia</a> was written, Flipswitch was not yet updated to support the new preferences system. Here is how it was fixed - by reading the plist from the disk and copying the data into the in-memory preferences cache:</p>

<pre><code class="objc">void HBCBPreferencesChanged() {
    NSDictionary *plist = [NSDictionary dictionaryWithContentsOfFile:[[[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@"Preferences"] stringByAppendingPathComponent:kHBCBPreferencesDomain] stringByAppendingPathExtension:@"plist"]];

    if (plist[kHBCBPreferencesSwitchesKey]) {
        [preferences setObject:plist[kHBCBPreferencesSwitchesKey] forKey:kHBCBPreferencesSwitchesKey];
    }
}

%ctor {
    HBCBPreferencesChanged();
    CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, (CFNotificationCallback)HBCBPreferencesChanged, CFSTR("ws.hbang.cobalia/ReloadPrefs"), NULL, kNilOptions);
}
</code></pre>

<p>Obviously you&rsquo;ll also need to set the appropriate key in your preference specifiers for a Darwin notification to be posted with the name you provide.</p>

<h2>Variable registration</h2>

<p>Finally, I want to explain the most powerful feature of <code>HBPreferences</code>: being able to &ldquo;register&rdquo; a variable so that its value is always kept up to date. This is quite easy to do:</p>

<pre><code class="objc">BOOL enabled;
NSArray *switches;
BOOL sectionLabel, switchLabel;

%init {
    HBPreferences *preferences = [HBPreferences preferencesWithIdentifier:@"ws.hbang.cobalia"];

    [preferences registerBool:&amp;enabled default:YES forKey:@"Enabled"];
    [preferences registerObject:&amp;switches default:@[ /* ... */ ] forKey:@"Switches"];
    [preferences registerBool:&amp;sectionLabel default:YES forKey:@"SectionLabel"];
    [preferences registerBool:&amp;switchLabel default:YES forKey:@"SwitchLabels"];
}
</code></pre>

<p>In your preference specifiers, ensure you have the <code>PostNotification</code> key set to the identifier you pass in to <code>HBPreferences</code>, followed by <code>/ReloadPrefs</code>. For example:</p>

<pre><code class="xml">&lt;dict&gt;
    &lt;key&gt;cell&lt;/key&gt;
    &lt;string&gt;PSSwitchCell&lt;/string&gt;
    &lt;key&gt;default&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;defaults&lt;/key&gt;
    &lt;string&gt;ws.hbang.cobalia&lt;/string&gt;
    &lt;key&gt;key&lt;/key&gt;
    &lt;string&gt;Enabled&lt;/string&gt;
    &lt;key&gt;label&lt;/key&gt;
    &lt;string&gt;Enabled&lt;/string&gt;
    &lt;key&gt;PostNotification&lt;/key&gt;
    &lt;string&gt;ws.hbang.cobalia/ReloadPrefs&lt;/string&gt;
&lt;/dict&gt;
</code></pre>

<p>And that&rsquo;s it - now all you need to do is refer to these variables as you always would. You don&rsquo;t need to worry at all about what happens when the user changes a setting; <code>HBPreferences</code> takes care of it for you and updates your variables.</p>

<p>If you want to learn more about what libcephei can do, take a look at <a href="https://hbang.github.io/libcephei/">its documentation</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up SSH via USB connection on Linux]]></title>
    <link href="http://sharedinstance.net/2015/02/setting-up-ssh-via-usb-connection-linux/"/>
    <updated>2015-02-15T10:06:18+10:30</updated>
    <id>http://sharedinstance.net/2015/02/setting-up-ssh-via-usb-connection-linux</id>
    <content type="html"><![CDATA[<p>This is a version of Aehmlo&rsquo;s original post, modified for Linux.</p>

<p>When developing tweaks (or making themes, for that matter), it is often annoying to wait for files to copy (and commands to execute) over Wi-Fi - it tends to be very slow and sometimes unreliable, and one must keep track of IP addresses and such (even if they use a hosts file to map custom hostnames) in order to accomplish it. This annoyance can be greatly relieved by creating a local tunnel over a USB connection to the target device, and using that to SSH to the device much more quickly and reliably. In this tutorial, we will cover how to set up your Linux PC (there are other posts for <a href="/2015/02/setting-up-ssh-via-usb-connection-win/">Windows</a> and <a href="/2014/12/setting-up-ssh-via-usb-connection/">OS X</a>) so that port 2222 is forwarded to port 22 on whatever device is plugged in.</p>

<!--more-->


<p>First things first, make sure you have a recent version of libimobiledevice installed, as well as its utilities. On Debian and Ubuntu, the package name is <code>libimobiledevice-utils</code>.</p>

<p>In a terminal, run the following command to start the tunneling:</p>

<pre><code class="bash">iproxy 2222 22
</code></pre>

<p>That&rsquo;s it!</p>

<p>Having this run all the time in the background is different depending on what daemon system your distro uses. If your distro uses Upstart, such as Ubuntu, create a file as root at <code>/etc/init/iproxy.conf</code>:</p>

<pre><code class="bash">sudo nano /etc/init/iproxy.conf
</code></pre>

<p>Enter the following:</p>

<pre><code>start on runlevel [2345]
stop on runlevel [!2345]

setuid nobody
setgid nogroup

exec /usr/bin/iproxy 2222 22
</code></pre>

<p>Use <code>sudo start iproxy</code> to start it without having to reboot.</p>

<p>Take a look at the <a href="/2014/12/setting-up-ssh-via-usb-connection/">original OS X post</a> to find out how to use this with Theos, and to prevent a false security error if you plug in a different device.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up SSH via USB connection on Windows]]></title>
    <link href="http://sharedinstance.net/2015/02/setting-up-ssh-via-usb-connection-win/"/>
    <updated>2015-02-15T09:58:08+10:30</updated>
    <id>http://sharedinstance.net/2015/02/setting-up-ssh-via-usb-connection-win</id>
    <content type="html"><![CDATA[<p>This is a version of Aehmlo&rsquo;s original post, modified for Windows.</p>

<p>When developing tweaks (or making themes, for that matter), it is often annoying to wait for files to copy (and commands to execute) over Wi-Fi - it tends to be very slow and sometimes unreliable, and one must keep track of IP addresses and such (even if they use a hosts file to map custom hostnames) in order to accomplish it. This annoyance can be greatly relieved by creating a local tunnel over a USB connection to the target device, and using that to SSH to the device much more quickly and reliably. In this tutorial, we will cover how to set up your Windows PC (there are other posts for <a href="/2015/02/setting-up-ssh-via-usb-connection-linux/">Linux</a> and <a href="/2014/12/setting-up-ssh-via-usb-connection/">OS X</a>) so that port 2222 is forwarded to port 22 on whatever device is plugged in.</p>

<!--more-->


<p>First things first, download the client from its <a href="https://code.google.com/p/iphonetunnel-usbmuxconnectbyport/downloads/detail?name=itunnel_mux_rev71.zip">download page</a> (note that you will need Windows XP and iTunes 10.5 or later for the client to work). Extract this zip - make sure you extract both the executable and the dll.</p>

<p>In Command Prompt, <code>cd</code> to the folder you extracted the zip to and run the following:</p>

<pre><code class="bash">itunnel_mux --iport 22 --lport 2222
</code></pre>

<p>From now on, the relay we have set up will always be running the background once you log in. Try it out in PuTTY by connecting to SSH at localhost, port 2222.</p>

<p>If you use Cygwin, you can easily register this as a Windows service so it&rsquo;s always running. You will need to use the Cygwin setup from <a href="https://cygwin.com">cygwin.com</a> to install <em>cygrunsrv</em>, under the Admin category. Now, from a Cygwin shell run as an administrator:</p>

<pre><code class="bash">cygrunsrv -I iTunnel -p /cygdrive/c/path/to/itunnel_mux.exe -a '--iport 22 --lport 2222' -u 'NETWORK SERVICE' -y 'Apple Mobile Device'
net start itunnel
</code></pre>

<p>This creates a service with the name <code>itunnel</code>, which will run itunnel_mux.exe with the provided arguments. It&rsquo;ll execute as Windows&#8217; built in <code>NetworkService</code> account, and requires the Apple Mobile Device service to be up and running before iTunnel can start.</p>

<p>When you update Cygwin packages, you should execute <code>net stop itunnel</code> (again, as an administrator) before the update and <code>net start itunnel</code> after. Otherwise, you may be told to restart your computer to replace in-use files.</p>

<p>Take a look at the <a href="/2014/12/setting-up-ssh-via-usb-connection/">original OS X post</a> to find out how to use this with Theos, and to prevent a false security error if you plug in a different device.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up SSH via USB connection on OS X]]></title>
    <link href="http://sharedinstance.net/2014/12/setting-up-ssh-via-usb-connection/"/>
    <updated>2014-12-28T15:03:02+10:30</updated>
    <id>http://sharedinstance.net/2014/12/setting-up-ssh-via-usb-connection</id>
    <content type="html"><![CDATA[<p>When developing tweaks (or making themes, for that matter), it is often annoying to wait for files to copy (and commands to execute) over Wi-Fi - it tends to be very slow and sometimes unreliable, and one must keep track of IP addresses and such (even if they use a hosts file to map custom hostnames) in order to accomplish it. This annoyance can be greatly relieved by creating a local tunnel over a USB connection to the target device, and using that to SSH to the device much more quickly and reliably. In this tutorial, we will cover how to set up your Mac (not PC, sorry - I am not knowledgable enough to write on this) so that port 2222 is forwarded to port 22 on whatever device is plugged in. This service will be started automatically and will run in the background at all times, out of sight and out of mind.</p>

<!--more-->


<p>First things first, download the client from its <a href="https://code.google.com/p/iphonetunnel-usbmuxconnectbyport/downloads/detail?name=itnl_rev8.zip">download page</a> (note that you will need iTunes 10.5 or later for the client to work). Extract this zip, and move the extracted contents to <code>~/Library/Application Support/usbmuxd/</code> (or something else, if you wish, but make sure to change the path in the plist accordingly) - both <code>tunl</code> and <code>libmd.dylib</code>.</p>

<p>Now, create a new file named <code>net.sharedinstance.tcprelay.plist</code> in <code>~/Library/LaunchAgents</code>. Inside this file, put the following:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;net.sharedinstance.tcprelay&lt;/string&gt;
    &lt;key&gt;KeepAlive&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;NetworkState&lt;/key&gt;
        &lt;true/&gt;
    &lt;/dict&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/Users/USER/Library/Application Support/usbmuxd/itnl&lt;/string&gt;
        &lt;string&gt;--iport&lt;/string&gt;
        &lt;string&gt;22&lt;/string&gt;
        &lt;/string&gt;--lport&lt;/string&gt;
        &lt;string&gt;2222&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>

<p>Be sure to replace USER above with your username (and if you put the executable elsewhere, make sure to change the first item in the ProgramArguments array to reflect that). Make sure that the itnl executable is, well, executable. Then, give the plist appropriate permissions - <code>chmod 0644 ~/Library/LaunchAgents/net.sharedinstance.tcprelay.plist</code>, and load this launch agent we have created - <code>launchctl load ~/Library/LaunchAgents/net.sharedinstance.tcprelay.plist</code>.</p>

<p>From now on, the relay we have set up will always be running the background once you log in. Try it out now with <code>ssh -p 2222 mobile@localhost</code>.</p>

<p>If you use this with multiple devices, you&rsquo;ll notice a problem: you&rsquo;ll get a scary host key changed warning:</p>

<pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
</code></pre>

<p>The trick to avoiding this is to set the known hosts file to <code>/dev/null</code> when you&rsquo;re connecting to localhost:2222. Create <code>~/.ssh/config</code> if you don&rsquo;t already have it and add the following:</p>

<pre><code>Host local
    User root
    HostName localhost
    Port 2222
    StrictHostKeyChecking no
    UserKnownHostsFile=/dev/null
</code></pre>

<p>You can now use <code>ssh local</code> no matter what device is plugged in.</p>

<p>To use this with Theos, you can export the IP to the host alias and the port to 2222:</p>

<pre><code class="bash">export THEOS_DEVICE_IP=local THEOS_DEVICE_PORT=2222
</code></pre>

<p>It would be ideal to also put this in your shell&rsquo;s profile script (<code>~/.bash_profile</code>, <code>~/.zshrc</code>, etc) so it&rsquo;s set by default and you don&rsquo;t have to worry about it.</p>

<p>Plug in a jailbroken iOS device, copy your SSH key to it if you haven&rsquo;t already&hellip;</p>

<pre><code class="bash">ssh local 'mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub
</code></pre>

<p>&hellip;and enjoy the blazingly fast transfer speed! Isn&rsquo;t this much better than boring ol&#8217; Wi-Fi?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Doing tweak settings the right way]]></title>
    <link href="http://sharedinstance.net/2014/11/settings-the-right-way/"/>
    <updated>2014-11-26T18:02:34+10:30</updated>
    <id>http://sharedinstance.net/2014/11/settings-the-right-way</id>
    <content type="html"><![CDATA[<p><strong>Please refer to the <a href="/2015/02/settings-the-right-way-redux/">revision</a> of this post.</strong></p>

<p>You might have noticed that tweak settings have suddenly started acting different in iOS 8. This is because the <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man8/cfprefsd.8.html"><code>cfprefsd</code></a> concept from OS X (as long ago as in 10.8 Mountain Lion) has been brought across to iOS 8. When you change a setting now, the dictionary is no longer committed to disk immediately - rather, it&rsquo;s kept in memory by <code>cfprefsd</code> and only flushed to disk when the appropriate process (or <code>cfprefsd</code> itself) terminates. So with that in mind, how do you manage settings on iOS 8 now?</p>

<!--more-->


<p>It&rsquo;s actually really simple and I&rsquo;d argue a thousand times better than the hack all of us were using before this. First, you need to keep an instance of NSUserDefaults hanging around, and register your default preferences:</p>

<pre><code class="objc">static NSString *const kHBCBPreferencesDomain = @"ws.hbang.cobalia";
static NSString *const kHBCBPreferencesEnabledKey = @"Enabled";
static NSString *const kHBCBPreferencesSwitchesKey = @"Switches";
static NSString *const kHBCBPreferencesSectionLabelKey = @"SectionLabel";
static NSString *const kHBCBPreferencesSwitchLabelsKey = @"SwitchLabels";

NSUserDefaults *userDefaults;

%init {
    userDefaults = [[NSUserDefaults alloc] _initWithSuiteName:kHBCBPreferencesDomain container:[NSURL URLWithString:@"/var/mobile"]];

    [userDefaults registerDefaults:@{
        kHBCBPreferencesEnabledKey: @YES,
        kHBCBPreferencesSwitchesKey: @[ /* ... */ ]
        kHBCBPreferencesSectionLabelKey: @YES,
        kHBCBPreferencesSwitchLabelsKey: @YES
    }]
}
</code></pre>

<p>You&rsquo;ll probably need to define this private init method in a category interface like so:</p>

<pre><code class="objc">@interface NSUserDefaults (Private)

- (instancetype)_initWithSuiteName:(NSString *)suiteName container:(NSURL *)container;

@end
</code></pre>

<p>I use constants for strings that shouldn&rsquo;t ever change - you don&rsquo;t need to but I&rsquo;d recommend it.</p>

<p>Now, it&rsquo;s as simple as a <code>[userDefaults boolForKey:@"Enabled"]</code> to grab a boolean, or <code>objectForKey:</code> for an Objective-C object, or any of the other methods <a href="https://developer.apple.com/Library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSUserDefaults_Class/index.html">the class supports</a>.</p>

<p>Easy! If you notice, you don&rsquo;t even need to watch for a traditional Darwin notification, nor do you need to define <code>PostNotification</code> on your preferences specifiers. The important thing to note is you need to directly call the methods on <code>NSUserDefaults</code> where ever you need to get a preference value in your code. You shouldn&rsquo;t store the preferences in separate global variables as you might have done traditionally since then you need a Darwin notification and a callback function to update them - ruining the simplicity of this solution.</p>

<p>But what about libraries like AppList or Flipswitch whose preferences API still write directly to the plist? The easiest thing you can do is a quick little trick to pass that back to <code>cfprefsd</code> to keep in memory. This is how I do it in <a href="https://github.com/hbang/Cobalia/blob/master/Tweak.xm">Cobalia</a>:</p>

<pre><code class="objc">void HBCBPreferencesChanged() {
    NSDictionary *preferences = [NSDictionary dictionaryWithContentsOfFile:[[[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@"Preferences"] stringByAppendingPathComponent:kHBCBPreferencesDomain] stringByAppendingPathExtension:@"plist"]];

    if (preferences[kHBCBPreferencesSwitchesKey]) {
        [userDefaults setObject:preferences[kHBCBPreferencesSwitchesKey] forKey:kHBCBPreferencesSwitchesKey];
    }
}

%ctor {
    HBCBPreferencesChanged();
    CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, (CFNotificationCallback)HBCBPreferencesChanged, CFSTR("ws.hbang.cobalia/ReloadPrefs"), NULL, kNilOptions);
}
</code></pre>

<p>Obviously you&rsquo;ll also need to set the appropriate key in your preference specifiers for a Darwin notification to be posted with the name you provide.</p>

<p>If you&rsquo;d like to see what else people are using for their tweaks, there are a few others you can explore that are listed on the iPhone Dev Wiki&rsquo;s <a href="http://iphonedevwiki.net/index.php/Updating_extensions_for_iOS_8#Preference_saving">updating extensions for iOS 8</a> article. To me, this is the most simple and elegant, and almost exactly what you&rsquo;d ideally be using anyway in a standard iOS or OS X application - but you&rsquo;re of course allowed to use whichever looks best to you.</p>
]]></content>
  </entry>
  
</feed>
